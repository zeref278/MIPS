.text
	.globl main
	
main:
	#HOW TO READ INTO A FILE
	
	li $v0,13           	# open_file syscall code = 13
    	la $a0,fileNameInput     	# get the file name
    	li $a1,0           	# file flag = read (0)
    	syscall
    	move $s0,$v0        	# save the file descriptor. $s0 = file
	
	#read the file
	li $v0, 14		# read_file syscall code = 14
	move $a0,$s0		# file descriptor
	la $a1,fileWords  	# The buffer that holds the string of the WHOLE file
	la $a2,1024		# hardcoded buffer length
	syscall

	
	
	jal atoi

	#Close the file
    	li $v0, 16         		# close_file syscall code
    	move $a0,$s0      		# file descriptor to close
    	syscall
    	
la $t0, array # Moves the address of array into register $t0.
addi $a0, $t0, 0 # Set argument 1 to the array.
addi $a1, $zero, 0 # Set argument 2 to (low = 0)
addi $a2, $t8, -1 # Set argument 3 to (high = 7, last index in array)

addi $sp,$sp,-4
sw $t8,0($sp)

li $t1,0
li $t2,0
li $t3,0
li $t4,0
li $t5,0
li $t6,0
li $t7,0



jal quicksort # Call quick sort
jal PrintArray
li $v0, 10 # Terminate program run and
syscall # Exit


swap:				#swap method

	addi $sp, $sp, -8	# Make stack room for three

	sw $ra,0($sp)		# store $ra
	sw $t2,4($sp)

	sll $t1, $a1, 2 	#t1 = 4a
	add $t1, $a0, $t1	#t1 = arr + 4a
	lw $s3, 0($t1)		#s3  t = array[a]

	sll $t2, $a2, 2		#t2 = 4b
	add $t2, $a0, $t2	#t2 = arr + 4b
	lw $s4, 0($t2)		#s4 = arr[b]

	sw $s4, 0($t1)		#arr[a] = arr[b]
	sw $s3, 0($t2)		#arr[b] = t 

 	lw $ra, 0($sp)		#restore return address
	lw $t2,4($sp)
 	addi $sp, $sp, 8		#restore the stack
 	jr $ra			#jump back to the caller
	


partition: 			#partition method

	addi $sp, $sp, -16	#Make room for 5

	sw $a0, 0($sp)		#store a0
	sw $a1, 4($sp)		#store a1
	sw $a2, 8($sp)		#store a2
	sw $ra, 12($sp)		#store return address
	
	move $s1, $a1		#s1 = low
	move $s2, $a2		#s2 = high

	sll $t1, $s2, 2		# t1 = 4*high
	add $t1, $a0, $t1	# t1 = arr + 4*high
	lw $t2, 0($t1)		# t2 = arr[high] //pivot

	addi $t3, $s1, -1 	#t3, i=low -1
	move $t4, $s1		#t4, j=low
	addi $t5, $s2, -1	#t5 = high - 1

	forloop: 
		slt $t6, $t5, $t4	#t6=1 if j>high-1, t6=0 if j<=high-1
		bne $t6, $zero, endfor	#if t6=1 then branch to endfor

		sll $t1, $t4, 2		#t1 = j*4
		add $t1, $t1, $a0	#t1 = arr + 4j
		lw $t7, 0($t1)		#t7 = arr[j]

		slt $t8, $t2, $t7	#t8 = 1 if pivot < arr[j], 0 if arr[j]<=pivot
		bne $t8, $zero, endfif	#if t8=1 then branch to endfif
		addi $t3, $t3, 1	#i=i+1

		move $a1, $t3		#a1 = i
		move $a2, $t4		#a2 = j
		jal swap		#swap(arr, i, j)
		
		addi $t4, $t4, 1	#j++
		j forloop

	    endfif:
		addi $t4, $t4, 1	#j++
		j forloop		#junp back to forloop

	endfor:
		addi $a1, $t3, 1		#a1 = i+1
		move $a2, $s2			#a2 = high
				#v0 = i+1 return (i + 1);
		jal swap			#swap(arr, i + 1, high);
		lw $a0, 0($sp)		#store a0
		lw $a1, 4($sp)		#store a1
		lw $a2, 8($sp)
		lw $ra, 12($sp)			#return address
		addi $sp, $sp, 16
		addi $v0, $t3, 1		#restore the stack
		jr $ra				#junp back to the caller

quicksort:				#quicksort method

	addi $sp, $sp, -16		# Make room for 4

	sw $a0, 0($sp)			# a0
	sw $a1, 4($sp)			# low
	sw $a2, 8($sp)			# high
	sw $ra, 12($sp)			# return address

	move $t0, $a2			#saving high in t0

	slt $t1, $a1, $t0		# t1=1 if low < high, else 0
	beq $t1, $zero, endif		# if low >= high, endif

	jal partition			# call partition 
	move $s0, $v0			# pivot, s0= v0

	lw $a1, 4($sp)			#a1 = low
	addi $a2, $s0, -1		#a2 = pi -1
	jal quicksort			#call quicksort

	addi $a1, $s0, 1		#a1 = pi + 1
	lw $a2, 8($sp)			#a2 = high
	jal quicksort			#call quicksort

 endif:

 	lw $a0, 0($sp)			#restore a0
 	lw $a1, 4($sp)			#restore a1
 	lw $a2, 8($sp)			#restore a2
 	lw $ra, 12($sp)			#restore return address
 	addi $sp, $sp, 16		#restore the stack
 	jr $ra				#return to caller
PrintArray:
	li $t9, 0
	lw $t8,0($sp)
	addi $sp,$sp,4
	sll $t8,$t8,2
	Loop1:

		beq $t9,$t8,ExitLoop1
		
		lw $t2, array($t9)

		
		add $v0,$0,1
		add $a0,$0,$t2
		syscall
		addi $v0, $0, 4
		la $a0, strNl
		syscall
		
		addi $t9,$t9,4
		
		j Loop1
	ExitLoop1:
		jr $ra

#######
atoi:
    or      $v0, $zero, $zero   # num = 0
.num:
    
    lb      $t0, 0($a1)
    slti    $t2, $t0, 58        # *str <= '9'
    slti    $t3, $t0, '0'       # *str < '0'
    beq     $t0,13, .numCount
    beq     $t0,10, .next
    beq     $t0, 32, .nextChar
    beq     $t2, $zero, .out
    bne     $t3, $zero, .out
    sll     $t2, $v0, 1
    sll     $v0, $v0, 3
    add     $v0, $v0, $t2       # num *= 10, using: num = (num << 3) + (num << 1)
    addi    $t0, $t0, -48
    add     $v0, $v0, $t0       # num += (*str - '0')
    addi    $a1, $a1, 1         # ++num
    
    j   .num

.next:
addi    $a1, $a1, 1
add $v0, $0,0

    j .num
.numCount:
	add $t8,$0,$v0 #so phan tu
addi    $a1, $a1, 1
add $v0, $0,0
	j .num
.nextChar:
    add $t7, $0, $v0

    sw $t7, array($s1)
    addi $s1, $s1, 4

    addi    $a1, $a1, 1

    add $v0, $0,0
    j .num
.out:
add $t7, $0, $v0

    sw $t7, array($s1)
    addi $s1, $s1, 4
    jr      $ra 

#STRINGS
.data
fileNameInput: .asciiz "D:/file.txt"
fileNameOutput: .asciiz "D:/testout.txt"
fileWords: .space 1024
array:  .word 0:999
strNl: .asciiz "\t"